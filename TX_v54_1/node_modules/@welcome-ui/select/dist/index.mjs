// src/index.tsx
import React2, { Fragment, useEffect, useMemo, useState } from "react";
import DownshiftImport from "downshift";
import { matchSorter } from "match-sorter";
import { DownIcon } from "@welcome-ui/icons";
import { ClearButton } from "@welcome-ui/clear-button";
import { forwardRef } from "@welcome-ui/system";
import {
  createEvent,
  FIELD_ICON_SIZE
} from "@welcome-ui/utils";
import { IconWrapper } from "@welcome-ui/field";

// src/utils.ts
var EMPTY_STRING = "";
var kebabCase = (str) => {
  if (typeof str === "number") {
    return String(str);
  } else if (typeof str === "string") {
    const match = str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g);
    return match && match.map((x) => x.toLowerCase()).join("-");
  }
};
var itemToString = (item) => item ? item.label : EMPTY_STRING;
var getSpacer = (options) => {
  return options.reduce(
    (prev, current) => current.label && prev.length > current.label.length ? prev : current.label,
    EMPTY_STRING
  );
};
var getUniqueValue = (item, values, allowUnselectFromList) => {
  const isExisting = values.find((value) => item.value === value.value);
  if (isExisting && allowUnselectFromList) {
    return values.filter((value) => item.value !== value.value);
  }
  return isExisting ? values : [...values, item];
};
var isValueSelected = (value, options) => !!options.find((item) => item.value === value);
var getOption = (value, options = []) => {
  const option = options.find(
    (option2) => option2.label === (value.label || value) || option2.value === (value.value || value)
  );
  return option || { value: kebabCase(value), label: value };
};
var getOptionsFromSelected = (selected, options) => {
  if (!selected && selected !== 0) {
    return [];
  } else if (Array.isArray(selected)) {
    return selected.map((value) => getOption(value, options));
  } else {
    return [getOption(selected, options)];
  }
};
var getIsExisting = (option, options) => !!options.find((item) => item.value === option.value);
var getValue = (option, options) => getIsExisting(option, options) ? option.value : option.label;
var getValuesFromOptions = (selected, options) => {
  if (!selected) {
    return;
  }
  return selected.map((selected2) => getValue(selected2, options));
};
var getNewOptions = (selected, options) => {
  if (!selected) {
    return;
  }
  return selected.filter((item) => !options.find((option) => option.value === item.value));
};
var getInputValue = ({
  inputValue,
  isMultiple,
  isSearchable,
  options,
  renderItem
}) => {
  const option = getOption(inputValue, options);
  if (isMultiple) {
    return inputValue;
  }
  if (option.label) {
    if (isSearchable) {
      return option.label;
    } else {
      return renderItem(option);
    }
  }
  return EMPTY_STRING;
};

// src/multipleSelections.tsx
import React from "react";
import { Tag } from "@welcome-ui/tag";

// src/styles.ts
import styled, { css, system, th } from "@xstyled/styled-components";
import { StyledIcon } from "@welcome-ui/icon";
import { StyledTag } from "@welcome-ui/tag";
import { shouldForwardProp } from "@welcome-ui/system";
import {
  cardStyles,
  centerContent,
  defaultFieldStyles,
  overflowEllipsis
} from "@welcome-ui/utils";
var Wrapper = styled("div").withConfig({ shouldForwardProp })`
  position: relative;
  ${system}
`;
var InputWrapper = styled.div`
  position: relative;
`;
var Input = styled("div").withConfig({ shouldForwardProp })(
  ({ iconPlacement, isClearable, size, transparent, variant }) => css`
    position: relative;
    ${defaultFieldStyles({
    size,
    variant,
    transparent,
    isClearable,
    iconPlacement
  })};
    ${overflowEllipsis};
    cursor: default;
    ${system}
    line-height: 1em;

    br {
      display: none;
    }

    &::before {
      content: attr(data-spacer);
      visibility: hidden;
      display: block;
      height: 0;
    }

    &:empty {
      &::after {
        content: attr(placeholder);
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        ${overflowEllipsis};
        padding: inherit;
        opacity: 0.5;
      }
      &::before {
        height: auto;
      }
    }
  `
);
var Menu = styled.ul`
  ${th("defaultFields.select.default")};
  ${cardStyles};
  position: absolute;
  z-index: 2;
  right: 0;
  left: 0;
  margin: 0;
  margin-top: md;
  padding: 0;
  transition: medium;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
`;
var Item = styled.li(
  ({
    allowUnselectFromList,
    isDisabled,
    isHighlighted,
    isMultiple,
    isSelected
  }) => css`
    color: nude-700;
    ${isHighlighted && th("defaultFields.select.highlighted")};
    ${isSelected && !isMultiple && th("defaultFields.select.selected")};
    ${isSelected && isMultiple && !allowUnselectFromList && th("defaultFields.select.existing")};
    ${isDisabled && th("defaultFields.select.disabled")};
    ${overflowEllipsis};
    padding: md;
    list-style: none;
    text-decoration: none;
    font-size: sm;
    transition: background ${th.transition("medium")};
  `
);
var Indicators = styled.div(
  ({ size }) => css`
    position: absolute;
    padding: 0;
    top: 0;
    bottom: 0;
    right: ${size === "xs" ? "sm" : "md"};
    display: flex;
    gap: xs;
  `
);
var DropDownIndicator = styled.button.withConfig({ shouldForwardProp })(
  ({ isOpen }) => css`
    position: relative;
    height: 100%;
    padding: 0;
    outline: none !important; /* important for firefox */
    appearance: none;
    cursor: pointer;
    border: none;
    background: transparent;
    ${centerContent};

    ${StyledIcon} {
      transform: ${isOpen ? "rotate3d(0, 0, 1, 180deg)" : "rotate3d(0)"};
      transition: medium;
    }

    &:not(:last-child) {
      width: auto;
    }
  `
);
var Tags = styled.div`
  margin-top: lg;

  ${/* sc-selector */
StyledTag}:not(:last-child) {
    margin-right: sm;
    margin-bottom: sm;
  }

  &:empty {
    display: none;
  }
`;

// src/multipleSelections.tsx
function multipleSelections(values, handleRemove) {
  return /* @__PURE__ */ React.createElement(Tags, { role: "list" }, values.map((tag) => /* @__PURE__ */ React.createElement(Tag, { key: tag.value, onRemove: () => handleRemove(tag.value.toString()), role: "listitem" }, tag.label)));
}

// src/index.tsx
var Downshift = DownshiftImport.default || DownshiftImport;
var Select = forwardRef(
  ({
    autoComplete = "off",
    autoFocus,
    dataTestId,
    disabled,
    icon,
    id,
    isClearable,
    isCreatable,
    isMultiple,
    isSearchable,
    options: defaultOptions = [],
    name,
    onBlur,
    onChange,
    onClick,
    onCreate,
    onFocus,
    placeholder = "Choose from\u2026",
    renderCreateItem = (inputValue) => `Create "${inputValue}"`,
    renderItem = itemToString,
    renderMultiple = multipleSelections,
    size = "md",
    value: defaultSelected,
    variant,
    allowUnselectFromList,
    disableCloseOnSelect,
    groupsEnabled,
    renderGroupHeader,
    transparent,
    ...rest
  }, ref) => {
    const defaultSelecteds = useMemo(
      () => getOptionsFromSelected(defaultSelected, defaultOptions),
      [defaultSelected, defaultOptions]
    );
    const selectedItem = !isMultiple && defaultSelecteds[0] || null;
    const defaultInputValue = selectedItem ? selectedItem.label : "";
    const [selected, setSelected] = useState(defaultSelecteds);
    const [inputValue, setInputValue] = useState(defaultInputValue);
    const [options, setOptions] = useState(defaultOptions);
    const [isOpen, setIsOpen] = useState(false);
    isSearchable = isCreatable || isSearchable;
    useEffect(() => {
      if (autoFocus) {
        ref?.current?.focus();
        isSearchable && setIsOpen(true);
      }
    }, [isSearchable, autoFocus, ref]);
    useEffect(() => {
      setSelected(defaultSelecteds);
      setInputValue(defaultInputValue);
      setOptions(defaultOptions);
    }, [defaultInputValue, defaultOptions, defaultSelecteds]);
    const handleInputChange = (value) => {
      if (isSearchable && value !== inputValue) {
        const options2 = matchSorter(defaultOptions, value, { keys: ["label"] });
        setInputValue(value);
        setOptions(options2);
      }
    };
    const handleInputKeyDown = () => {
      if (isSearchable && !isOpen) {
        setIsOpen(true);
      }
    };
    const handleChange = (options2) => {
      const values = getValuesFromOptions(options2, defaultOptions);
      const value = isMultiple ? values : values[0];
      const event = createEvent({ name, value: isMultiple ? options2 : options2[0] });
      onChange && onChange(value, event);
      if (isCreatable) {
        const newOptions = getNewOptions(options2, defaultOptions);
        if (newOptions.length) {
          onCreate && onCreate(newOptions[0].label, event);
        }
      }
    };
    const handleSelect = (option) => {
      let newItems;
      let isClearInput;
      if (!option || option?.disabled) {
        newItems = isMultiple ? selected : [];
        isClearInput = true;
      } else {
        newItems = isMultiple ? getUniqueValue(option, selected, allowUnselectFromList) : [option];
        isClearInput = isMultiple;
      }
      isClearInput && setInputValue("");
      setOptions(defaultOptions);
      setSelected(newItems);
      handleChange(newItems);
      if (!disableCloseOnSelect) {
        setIsOpen(false);
      }
    };
    const handleRemove = (value) => {
      const newItems = selected.filter((item) => item.value !== value);
      setSelected(newItems);
      handleChange(newItems);
    };
    const handleOuterClick = (e) => {
      if (isMultiple && e.selectedItem) {
        setInputValue("");
      } else if (isSearchable && e.selectedItem) {
        setInputValue(e.selectedItem.label);
      }
      setOptions(defaultOptions);
      setIsOpen(false);
    };
    const spacer = getSpacer(defaultOptions);
    const inputContent = getInputValue({
      inputValue,
      isMultiple,
      isSearchable,
      options: defaultOptions,
      renderItem
    });
    return /* @__PURE__ */ React2.createElement(
      Downshift,
      {
        id,
        inputValue: isSearchable ? inputContent : "",
        isOpen,
        itemToString,
        onInputValueChange: handleInputChange,
        onOuterClick: handleOuterClick,
        onSelect: handleSelect,
        selectedItem
      },
      ({
        clearSelection,
        getInputProps,
        getItemProps,
        getMenuProps,
        getRootProps,
        getToggleButtonProps,
        highlightedIndex
      }) => {
        const isShowCreate = !!(isCreatable && inputValue && !isValueSelected(inputValue, selected));
        const isShowMenu = isOpen && (options.length || isShowCreate);
        const isShowDeleteIcon = isClearable && inputValue;
        const DeleteIcon = /* @__PURE__ */ React2.createElement(DropDownIndicator, { as: "div" }, /* @__PURE__ */ React2.createElement(
          ClearButton,
          {
            onClick: clearSelection
          }
        ));
        const ArrowIcon = /* @__PURE__ */ React2.createElement(
          DropDownIndicator,
          {
            "data-testid": dataTestId && `${dataTestId}-arrow-icon`,
            disabled,
            isOpen,
            size,
            tabIndex: -1,
            ...getToggleButtonProps({
              onClick: () => setIsOpen(!isOpen)
            })
          },
          /* @__PURE__ */ React2.createElement(DownIcon, { color: "dark-900", size: "sm" })
        );
        const handleInputClick = (e) => {
          onClick && onClick(e);
          setIsOpen(!isOpen);
        };
        const rootProps = getRootProps(rest);
        const inputProps = getInputProps({
          autoComplete,
          autoFocus,
          "data-spacer": spacer || placeholder,
          "data-testid": dataTestId,
          disabled,
          iconPlacement: icon ? "both" : "right",
          id,
          name,
          onBlur,
          onClick: disabled ? void 0 : handleInputClick,
          onFocus,
          onKeyDown: handleInputKeyDown,
          placeholder,
          ref,
          size,
          tabIndex: 0,
          variant: isOpen ? "focused" : variant,
          isClearable,
          transparent,
          ...rest
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        });
        const iconSize = FIELD_ICON_SIZE[size];
        return /* @__PURE__ */ React2.createElement(Wrapper, { ...rootProps }, /* @__PURE__ */ React2.createElement(InputWrapper, null, isSearchable ? /* @__PURE__ */ React2.createElement(Input, { as: "input", type: "text", ...inputProps }) : /* @__PURE__ */ React2.createElement(Input, { ...inputProps }, inputContent), icon && /* @__PURE__ */ React2.createElement(IconWrapper, { iconPlacement: "left", size: iconSize }, React2.cloneElement(icon, { ...icon.props, size: iconSize })), /* @__PURE__ */ React2.createElement(Indicators, { size }, isShowDeleteIcon && DeleteIcon, ArrowIcon)), isShowMenu && /* @__PURE__ */ React2.createElement(Menu, { ...getMenuProps() }, options.reduce(
          (acc, result, resultIndex) => {
            if (groupsEnabled && "options" in result) {
              acc.itemsToRender.push(
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                /* @__PURE__ */ React2.createElement(Fragment, { key: result.label }, renderGroupHeader(result), result.options && result.options.map((option) => {
                  const index = acc.itemIndex++;
                  const isItemSelected = isValueSelected(option.value, selected);
                  return /* @__PURE__ */ React2.createElement(
                    Item,
                    {
                      allowUnselectFromList,
                      isDisabled: option.disabled,
                      isHighlighted: highlightedIndex === index,
                      isMultiple,
                      key: option.value,
                      ...getItemProps({
                        index,
                        isSelected: isItemSelected,
                        item: option
                      })
                    },
                    renderItem(option, isItemSelected)
                  );
                }))
              );
            } else if ("value" in result) {
              const isItemSelected = isValueSelected(result.value, selected);
              acc.itemsToRender.push(
                /* @__PURE__ */ React2.createElement(
                  Item,
                  {
                    allowUnselectFromList,
                    isDisabled: result.disabled,
                    isHighlighted: highlightedIndex === resultIndex,
                    isMultiple,
                    key: result.value,
                    ...getItemProps({
                      index: resultIndex,
                      isSelected: isItemSelected,
                      item: result
                    })
                  },
                  renderItem(result, isItemSelected)
                )
              );
            }
            return acc;
          },
          { itemsToRender: [], itemIndex: 0 }
        ).itemsToRender, isShowCreate && inputValue.length && /* @__PURE__ */ React2.createElement(
          Item,
          {
            isHighlighted: highlightedIndex === options.length,
            key: "add",
            ...getItemProps({
              index: options.length,
              item: {
                value: kebabCase(inputValue),
                label: inputValue
              }
            })
          },
          renderCreateItem(inputValue)
        )), isMultiple && renderMultiple(selected, handleRemove));
      }
    );
  }
);
var StyledSelect = Wrapper;
export {
  Select,
  StyledSelect
};
