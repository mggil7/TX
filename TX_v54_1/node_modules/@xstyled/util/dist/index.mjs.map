{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import { Props, Path } from './types'\n\nexport * from './types'\n\nconst DEV = process.env.NODE_ENV !== 'production'\n\nconst specialProperties = ['__proto__', 'constructor', 'prototype']\n/**\n * Identity function.\n */\nexport const identity = <T>(x: T): T => x\n\n/**\n * Check if a value is not null and not undefined.\n */\nexport const is = <T>(n: T): n is Exclude<T, undefined | null> =>\n  n !== undefined && n !== null\n\n/**\n * Check if a value is a number.\n */\nexport const num = (n: unknown): n is number =>\n  typeof n === 'number' && !Number.isNaN(n)\n\n/**\n * Check if a value is a string.\n */\nexport const string = (n: unknown): n is Exclude<string, ''> =>\n  typeof n === 'string' && n !== ''\n\n/**\n * Check if a value is an object.\n */\nexport const obj = (\n  n: unknown,\n): n is { [key: string]: unknown; [key: number]: unknown } =>\n  typeof n === 'object' && n !== null\n\n/**\n * Check if a value is a function.\n */\nexport const func = (n: unknown): n is Function => typeof n === 'function'\n\n/**\n * Check if a value is a negative number.\n */\nexport const negative = (n: unknown): n is number => num(n) && n < 0\n\n/**\n * Get a value from an object or an array.\n */\nexport const get = (from: unknown, path: Path): unknown => {\n  const paths = String(path).split('.')\n  const pathsLength = paths.length\n  let result: any = from\n  for (let i = 0; i < pathsLength; i += 1) {\n    if (!is(result)) return result\n    const path = paths[i]\n    result = is(result[path]) ? result[path] : undefined\n  }\n  return result\n}\n\n/**\n * Assign object into another\n */\nexport const assign = <T, U>(target: T, source: U): T & U => {\n  if (!is(source)) return target as T & U\n  for (const key in source) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue\n    }\n    // @ts-ignore\n    target[key] = source[key]\n  }\n  return target as T & U\n}\n\n/**\n * Merge deeply one object into another.\n */\nexport const merge = <T, U>(target: T, source: U): T & U => {\n  if (!is(source)) return target as T & U\n  for (const key in source) {\n    if (specialProperties.indexOf(key) !== -1) {\n      continue\n    }\n    // @ts-ignore\n    if (obj(target[key])) {\n      // @ts-ignore\n      target[key] = merge(assign({}, target[key]), source[key])\n    } else {\n      // @ts-ignore\n      target[key] = source[key]\n    }\n  }\n  return target as T & U\n}\n\n/**\n * Warn if a condition is not met.\n */\nexport const warn = (condition: boolean, message: string): void => {\n  if (DEV) {\n    if (!condition && console.error) {\n      console.error(message)\n    }\n  }\n}\n\n/**\n * Recursively call a function until getting something that is not a function.\n */\nexport function cascade(value: unknown, arg?: unknown): Exclude<any, Function> {\n  if (typeof value === 'function') {\n    return cascade(value(arg), arg)\n  }\n  return value\n}\n\n/**\n * Get value from theme.\n */\nexport const getThemeValue = <T extends Props>(\n  props: T,\n  path: Path,\n  initial: unknown = props.theme,\n): unknown => cascade(get(initial, path), props)\n\n/**\n * Omit values from an object.\n */\nexport function omit<T extends { [key: string]: unknown }, K extends string[]>(\n  object: T,\n  values: K,\n): Pick<T, Exclude<keyof T, K[number]>> {\n  const result: { [key: string]: unknown } = {}\n  for (const key in object) {\n    if (values.indexOf(key) === -1) {\n      result[key] = object[key]\n    }\n  }\n  return result as Pick<T, Exclude<keyof T, K[number]>>\n}\n\n/**\n * Flatten every string together in an array.\n */\nexport function flattenStrings(array: any[]): any[] {\n  return array.reduce((flattenedArray, value) => {\n    const lastIndex = flattenedArray.length - 1\n    const last = flattenedArray[lastIndex]\n    if (typeof last === 'string' && typeof value === 'string') {\n      flattenedArray[lastIndex] = last + value\n    } else {\n      flattenedArray.push(value)\n    }\n    return flattenedArray\n  }, [])\n}\n\nfunction flattenDown(array: any[], result: any[]) {\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenDown(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array.\n */\nexport function flatten(array: any[]): any[] {\n  return flattenDown(array, [])\n}\n"],"names":["path"],"mappings":"AAIA,MAAM,GAAA,GAAM,OAAQ,CAAA,GAAA,CAAI,QAAa,KAAA,YAAA,CAAA;AAErC,MAAM,iBAAoB,GAAA,CAAC,WAAa,EAAA,aAAA,EAAe,WAAW,CAAA,CAAA;AAIrD,MAAA,QAAA,GAAW,CAAI,CAAY,KAAA,EAAA;AAKjC,MAAM,EAAK,GAAA,CAAI,CACpB,KAAA,CAAA,KAAM,UAAa,CAAM,KAAA,KAAA;AAKd,MAAA,GAAA,GAAM,CAAC,CAClB,KAAA,OAAO,MAAM,QAAY,IAAA,CAAC,MAAO,CAAA,KAAA,CAAM,CAAC,EAAA;AAKnC,MAAM,SAAS,CAAC,CAAA,KACrB,OAAO,CAAA,KAAM,YAAY,CAAM,KAAA,GAAA;AAK1B,MAAM,MAAM,CACjB,CAAA,KAEA,OAAO,CAAA,KAAM,YAAY,CAAM,KAAA,KAAA;AAK1B,MAAM,IAAO,GAAA,CAAC,CAA8B,KAAA,OAAO,CAAM,KAAA,WAAA;AAKzD,MAAM,WAAW,CAAC,CAAA,KAA4B,GAAI,CAAA,CAAC,KAAK,CAAI,GAAA,EAAA;AAKtD,MAAA,GAAA,GAAM,CAAC,IAAA,EAAe,IAAwB,KAAA;AACzD,EAAA,MAAM,KAAQ,GAAA,MAAA,CAAO,IAAI,CAAA,CAAE,MAAM,GAAG,CAAA,CAAA;AACpC,EAAA,MAAM,cAAc,KAAM,CAAA,MAAA,CAAA;AAC1B,EAAA,IAAI,MAAc,GAAA,IAAA,CAAA;AAClB,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,KAAK,CAAG,EAAA;AACvC,IAAI,IAAA,CAAC,GAAG,MAAM,CAAA;AAAG,MAAO,OAAA,MAAA,CAAA;AACxB,IAAA,MAAMA,QAAO,KAAM,CAAA,CAAA,CAAA,CAAA;AACnB,IAAA,MAAA,GAAS,EAAG,CAAA,MAAA,CAAOA,KAAK,CAAA,CAAA,GAAI,OAAOA,KAAQ,CAAA,GAAA,KAAA,CAAA,CAAA;AAAA,GAC7C;AACA,EAAO,OAAA,MAAA,CAAA;AACT,EAAA;AAKa,MAAA,MAAA,GAAS,CAAO,MAAA,EAAW,MAAqB,KAAA;AAC3D,EAAI,IAAA,CAAC,GAAG,MAAM,CAAA;AAAG,IAAO,OAAA,MAAA,CAAA;AACxB,EAAA,KAAA,MAAW,OAAO,MAAQ,EAAA;AACxB,IAAA,IAAI,iBAAkB,CAAA,OAAA,CAAQ,GAAG,CAAA,KAAM,CAAI,CAAA,EAAA;AACzC,MAAA,SAAA;AAAA,KACF;AAEA,IAAA,MAAA,CAAO,OAAO,MAAO,CAAA,GAAA,CAAA,CAAA;AAAA,GACvB;AACA,EAAO,OAAA,MAAA,CAAA;AACT,EAAA;AAKa,MAAA,KAAA,GAAQ,CAAO,MAAA,EAAW,MAAqB,KAAA;AAC1D,EAAI,IAAA,CAAC,GAAG,MAAM,CAAA;AAAG,IAAO,OAAA,MAAA,CAAA;AACxB,EAAA,KAAA,MAAW,OAAO,MAAQ,EAAA;AACxB,IAAA,IAAI,iBAAkB,CAAA,OAAA,CAAQ,GAAG,CAAA,KAAM,CAAI,CAAA,EAAA;AACzC,MAAA,SAAA;AAAA,KACF;AAEA,IAAI,IAAA,GAAA,CAAI,MAAO,CAAA,GAAA,CAAI,CAAG,EAAA;AAEpB,MAAO,MAAA,CAAA,GAAA,CAAA,GAAO,MAAM,MAAO,CAAA,IAAI,MAAO,CAAA,GAAA,CAAI,CAAG,EAAA,MAAA,CAAO,GAAI,CAAA,CAAA,CAAA;AAAA,KACnD,MAAA;AAEL,MAAA,MAAA,CAAO,OAAO,MAAO,CAAA,GAAA,CAAA,CAAA;AAAA,KACvB;AAAA,GACF;AACA,EAAO,OAAA,MAAA,CAAA;AACT,EAAA;AAKa,MAAA,IAAA,GAAO,CAAC,SAAA,EAAoB,OAA0B,KAAA;AACjE,EAAA,IAAI,GAAK,EAAA;AACP,IAAI,IAAA,CAAC,SAAa,IAAA,OAAA,CAAQ,KAAO,EAAA;AAC/B,MAAA,OAAA,CAAQ,MAAM,OAAO,CAAA,CAAA;AAAA,KACvB;AAAA,GACF;AACF,EAAA;AAKgB,SAAA,OAAA,CAAQ,OAAgB,GAAuC,EAAA;AAC7E,EAAI,IAAA,OAAO,UAAU,UAAY,EAAA;AAC/B,IAAA,OAAO,OAAQ,CAAA,KAAA,CAAM,GAAG,CAAA,EAAG,GAAG,CAAA,CAAA;AAAA,GAChC;AACA,EAAO,OAAA,KAAA,CAAA;AACT,CAAA;AAKO,MAAM,aAAgB,GAAA,CAC3B,KACA,EAAA,IAAA,EACA,OAAmB,GAAA,KAAA,CAAM,KACb,KAAA,OAAA,CAAQ,GAAI,CAAA,OAAA,EAAS,IAAI,CAAA,EAAG,KAAK,EAAA;AAK/B,SAAA,IAAA,CACd,QACA,MACsC,EAAA;AACtC,EAAA,MAAM,SAAqC,EAAC,CAAA;AAC5C,EAAA,KAAA,MAAW,OAAO,MAAQ,EAAA;AACxB,IAAA,IAAI,MAAO,CAAA,OAAA,CAAQ,GAAG,CAAA,KAAM,CAAI,CAAA,EAAA;AAC9B,MAAA,MAAA,CAAO,OAAO,MAAO,CAAA,GAAA,CAAA,CAAA;AAAA,KACvB;AAAA,GACF;AACA,EAAO,OAAA,MAAA,CAAA;AACT,CAAA;AAKO,SAAS,eAAe,KAAqB,EAAA;AAClD,EAAA,OAAO,KAAM,CAAA,MAAA,CAAO,CAAC,cAAA,EAAgB,KAAU,KAAA;AAC7C,IAAM,MAAA,SAAA,GAAY,eAAe,MAAS,GAAA,CAAA,CAAA;AAC1C,IAAA,MAAM,OAAO,cAAe,CAAA,SAAA,CAAA,CAAA;AAC5B,IAAA,IAAI,OAAO,IAAA,KAAS,QAAY,IAAA,OAAO,UAAU,QAAU,EAAA;AACzD,MAAA,cAAA,CAAe,aAAa,IAAO,GAAA,KAAA,CAAA;AAAA,KAC9B,MAAA;AACL,MAAA,cAAA,CAAe,KAAK,KAAK,CAAA,CAAA;AAAA,KAC3B;AACA,IAAO,OAAA,cAAA,CAAA;AAAA,GACT,EAAG,EAAE,CAAA,CAAA;AACP,CAAA;AAEA,SAAS,WAAA,CAAY,OAAc,MAAe,EAAA;AAChD,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,CAAM,QAAQ,CAAK,EAAA,EAAA;AACrC,IAAA,MAAM,QAAQ,KAAM,CAAA,CAAA,CAAA,CAAA;AAEpB,IAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAG,EAAA;AACxB,MAAA,WAAA,CAAY,OAAO,MAAM,CAAA,CAAA;AAAA,KACpB,MAAA;AACL,MAAA,MAAA,CAAO,KAAK,KAAK,CAAA,CAAA;AAAA,KACnB;AAAA,GACF;AAEA,EAAO,OAAA,MAAA,CAAA;AACT,CAAA;AAKO,SAAS,QAAQ,KAAqB,EAAA;AAC3C,EAAO,OAAA,WAAA,CAAY,KAAO,EAAA,EAAE,CAAA,CAAA;AAC9B;;;;"}