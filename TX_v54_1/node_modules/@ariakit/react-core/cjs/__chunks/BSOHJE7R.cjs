"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _Q6W7IWNJcjs = require('./Q6W7IWNJ.cjs');


var _GQAB4M3Bcjs = require('./GQAB4M3B.cjs');




var _Z5PUIG6Acjs = require('./Z5PUIG6A.cjs');





var _5WLTMVVQcjs = require('./5WLTMVVQ.cjs');




var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/hovercard/hovercard-anchor.ts
var _react = require('react');
var _events = require('@ariakit/core/utils/events');
var _misc = require('@ariakit/core/utils/misc');
var useHovercardAnchor = _Z5PUIG6Acjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, { store, showOnHover = true } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, ["store", "showOnHover"]);
    const context = _Q6W7IWNJcjs.useHovercardProviderContext.call(void 0, );
    store = store || context;
    _misc.invariant.call(void 0, 
      store,
      process.env.NODE_ENV !== "production" && "HovercardAnchor must receive a `store` prop or be wrapped in a HovercardProvider component."
    );
    const mounted = store.useState("mounted");
    const disabled = props.disabled || props["aria-disabled"] === true || props["aria-disabled"] === "true";
    const showTimeoutRef = _react.useRef.call(void 0, 0);
    _react.useEffect.call(void 0, () => () => window.clearTimeout(showTimeoutRef.current), []);
    _react.useEffect.call(void 0, () => {
      const onMouseLeave = (event) => {
        if (!store)
          return;
        const { anchorElement } = store.getState();
        if (!anchorElement)
          return;
        if (event.target !== anchorElement)
          return;
        window.clearTimeout(showTimeoutRef.current);
        showTimeoutRef.current = 0;
      };
      return _events.addGlobalEventListener.call(void 0, "mouseleave", onMouseLeave, true);
    }, [store]);
    const onMouseMoveProp = props.onMouseMove;
    const showOnHoverProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, showOnHover);
    const isMouseMoving = _5WLTMVVQcjs.useIsMouseMoving.call(void 0, );
    const onMouseMove = _5WLTMVVQcjs.useEvent.call(void 0, 
      (event) => {
        store == null ? void 0 : store.setAnchorElement(event.currentTarget);
        onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
        if (disabled)
          return;
        if (event.defaultPrevented)
          return;
        if (showTimeoutRef.current)
          return;
        if (!isMouseMoving())
          return;
        if (!store)
          return;
        if (!showOnHoverProp(event))
          return;
        const { showTimeout, timeout } = store.getState();
        showTimeoutRef.current = window.setTimeout(() => {
          showTimeoutRef.current = 0;
          if (!isMouseMoving())
            return;
          store == null ? void 0 : store.show();
        }, showTimeout != null ? showTimeout : timeout);
      }
    );
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props), {
      ref: _5WLTMVVQcjs.useMergeRefs.call(void 0, 
        store.setAnchorElement,
        // We need to set the anchor element as the hovercard disclosure
        // disclosure element only when the hovercard is shown so it doesn't get
        // assigned an arbitrary element by the dialog component.
        mounted ? store.setDisclosureElement : void 0,
        props.ref
      ),
      onMouseMove
    });
    props = _GQAB4M3Bcjs.useFocusable.call(void 0, props);
    return props;
  }
);
var HovercardAnchor = _Z5PUIG6Acjs.createComponent.call(void 0, 
  (props) => {
    const htmlProps = useHovercardAnchor(props);
    return _Z5PUIG6Acjs.createElement.call(void 0, "a", htmlProps);
  }
);
if (process.env.NODE_ENV !== "production") {
  HovercardAnchor.displayName = "HovercardAnchor";
}




exports.useHovercardAnchor = useHovercardAnchor; exports.HovercardAnchor = HovercardAnchor;
