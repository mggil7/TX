"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _R7CSCUVWcjs = require('./R7CSCUVW.cjs');


var _RWS2MAR2cjs = require('./RWS2MAR2.cjs');


var _DFFFHQVQcjs = require('./DFFFHQVQ.cjs');


var _W32FX7DMcjs = require('./W32FX7DM.cjs');



var _QK4GI6B3cjs = require('./QK4GI6B3.cjs');



var _COHI5HTScjs = require('./COHI5HTS.cjs');


var _F4RJLWZGcjs = require('./F4RJLWZG.cjs');


var _TLA46MN6cjs = require('./TLA46MN6.cjs');


var _VTRMALP6cjs = require('./VTRMALP6.cjs');


var _A6H7IIHJcjs = require('./A6H7IIHJ.cjs');


var _SOPRUU56cjs = require('./SOPRUU56.cjs');


var _MNZPRWGCcjs = require('./MNZPRWGC.cjs');



var _L2VQ4YLNcjs = require('./L2VQ4YLN.cjs');





var _W6ZRSMO5cjs = require('./W6ZRSMO5.cjs');


var _GQAB4M3Bcjs = require('./GQAB4M3B.cjs');




var _Z5PUIG6Acjs = require('./Z5PUIG6A.cjs');


var _ZZZ5MQHAcjs = require('./ZZZ5MQHA.cjs');


var _EVNF7KMTcjs = require('./EVNF7KMT.cjs');








var _5WLTMVVQcjs = require('./5WLTMVVQ.cjs');




var _72I2GWXFcjs = require('./72I2GWXF.cjs');

// src/dialog/dialog.tsx
var _react = require('react');






var _dom = require('@ariakit/core/utils/dom');



var _events = require('@ariakit/core/utils/events');




var _focus = require('@ariakit/core/utils/focus');
var _misc = require('@ariakit/core/utils/misc');
var _platform = require('@ariakit/core/utils/platform');
var _jsxruntime = require('react/jsx-runtime');
var isSafariBrowser = _platform.isSafari.call(void 0, );
function isAlreadyFocusingAnotherElement(dialog) {
  const activeElement = _dom.getActiveElement.call(void 0, );
  if (!activeElement)
    return false;
  if (dialog && _dom.contains.call(void 0, dialog, activeElement))
    return false;
  if (_focus.isFocusable.call(void 0, activeElement))
    return true;
  return false;
}
function getElementFromProp(prop, focusable = false) {
  if (!prop)
    return null;
  const element = "current" in prop ? prop.current : prop;
  if (!element)
    return null;
  if (focusable)
    return _focus.isFocusable.call(void 0, element) ? element : null;
  return element;
}
var useDialog = _Z5PUIG6Acjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store: storeProp,
      open: openProp,
      onClose,
      focusable = true,
      modal = true,
      portal = !!modal,
      backdrop = !!modal,
      backdropProps,
      hideOnEscape = true,
      hideOnInteractOutside = true,
      getPersistentElements,
      preventBodyScroll = !!modal,
      autoFocusOnShow = true,
      autoFocusOnHide = true,
      initialFocus,
      finalFocus,
      unmountOnHide
    } = _b, props = _72I2GWXFcjs.__objRest.call(void 0, _b, [
      "store",
      "open",
      "onClose",
      "focusable",
      "modal",
      "portal",
      "backdrop",
      "backdropProps",
      "hideOnEscape",
      "hideOnInteractOutside",
      "getPersistentElements",
      "preventBodyScroll",
      "autoFocusOnShow",
      "autoFocusOnHide",
      "initialFocus",
      "finalFocus",
      "unmountOnHide"
    ]);
    const context = _W6ZRSMO5cjs.useDialogProviderContext.call(void 0, );
    const ref = _react.useRef.call(void 0, null);
    const store = _ZZZ5MQHAcjs.useDialogStore.call(void 0, {
      store: storeProp || context,
      open: openProp,
      setOpen(open2) {
        if (open2)
          return;
        const dialog = ref.current;
        if (!dialog)
          return;
        const event = new Event("close", { bubbles: false, cancelable: true });
        if (onClose) {
          dialog.addEventListener("close", onClose, { once: true });
        }
        dialog.dispatchEvent(event);
        if (!event.defaultPrevented)
          return;
        store.setOpen(true);
      }
    });
    const { portalRef, domReady } = _5WLTMVVQcjs.usePortalRef.call(void 0, portal, props.portalRef);
    const preserveTabOrderProp = props.preserveTabOrder;
    const preserveTabOrder = store.useState(
      (state) => preserveTabOrderProp && !modal && state.mounted
    );
    const id = _5WLTMVVQcjs.useId.call(void 0, props.id);
    const open = store.useState("open");
    const mounted = store.useState("mounted");
    const contentElement = store.useState("contentElement");
    const hidden = _L2VQ4YLNcjs.isHidden.call(void 0, mounted, props.hidden, props.alwaysVisible);
    _VTRMALP6cjs.usePreventBodyScroll.call(void 0, contentElement, id, preventBodyScroll && !hidden);
    _DFFFHQVQcjs.useHideOnInteractOutside.call(void 0, store, hideOnInteractOutside, domReady);
    const { wrapElement, nestedDialogs } = _RWS2MAR2cjs.useNestedDialogs.call(void 0, store);
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, props, wrapElement, [wrapElement]);
    if (process.env.NODE_ENV !== "production") {
      _react.useEffect.call(void 0, () => {
        if (!backdropProps)
          return;
        console.warn(
          "The `backdropProps` prop is deprecated. Use the `backdrop` prop instead.",
          "See https://ariakit.org/reference/dialog#backdrop"
        );
      }, [backdropProps]);
    }
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!open)
        return;
      const dialog = ref.current;
      const activeElement = _dom.getActiveElement.call(void 0, dialog, true);
      if (!activeElement)
        return;
      if (activeElement.tagName === "BODY")
        return;
      if (dialog && _dom.contains.call(void 0, dialog, activeElement))
        return;
      store.setDisclosureElement(activeElement);
    }, [store, open]);
    if (isSafariBrowser) {
      _react.useEffect.call(void 0, () => {
        if (!mounted)
          return;
        const { disclosureElement } = store.getState();
        if (!disclosureElement)
          return;
        if (!_dom.isButton.call(void 0, disclosureElement))
          return;
        const onMouseDown = () => {
          let receivedFocus = false;
          const onFocus = () => {
            receivedFocus = true;
          };
          const options = { capture: true, once: true };
          disclosureElement.addEventListener("focusin", onFocus, options);
          _events.queueBeforeEvent.call(void 0, disclosureElement, "mouseup", () => {
            disclosureElement.removeEventListener("focusin", onFocus, true);
            if (receivedFocus)
              return;
            _focus.focusIfNeeded.call(void 0, disclosureElement);
          });
        };
        disclosureElement.addEventListener("mousedown", onMouseDown);
        return () => {
          disclosureElement.removeEventListener("mousedown", onMouseDown);
        };
      }, [store, mounted]);
    }
    const shouldDisableAccessibilityTree = modal || // Usually, we only want to disable the accessibility tree outside if the
    // dialog is a modal. But the Portal component can't preserve the tab
    // order on Safari/VoiceOver. By allowing only the dialog/portal to be
    // accessible, we provide a similar tab order flow. We don't need to
    // disable pointer events because it's just for screen readers.
    portal && preserveTabOrder && _platform.isSafari.call(void 0, );
    _react.useEffect.call(void 0, () => {
      if (!mounted)
        return;
      if (!domReady)
        return;
      const dialog = ref.current;
      if (!dialog)
        return;
      if (!shouldDisableAccessibilityTree)
        return;
      const existingDismiss = dialog.querySelector("[data-dialog-dismiss]");
      if (existingDismiss)
        return;
      return _W32FX7DMcjs.prependHiddenDismiss.call(void 0, dialog, store.hide);
    }, [store, mounted, domReady, shouldDisableAccessibilityTree]);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (open)
        return;
      if (!mounted)
        return;
      if (!domReady)
        return;
      const dialog = ref.current;
      if (!dialog)
        return;
      return _COHI5HTScjs.disableTree.call(void 0, dialog);
    }, [open, mounted, domReady]);
    const canTakeTreeSnapshot = open && domReady;
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!id)
        return;
      if (!canTakeTreeSnapshot)
        return;
      const dialog = ref.current;
      return _TLA46MN6cjs.createWalkTreeSnapshot.call(void 0, id, [dialog]);
    }, [id, canTakeTreeSnapshot]);
    const getPersistentElementsProp = _5WLTMVVQcjs.useEvent.call(void 0, getPersistentElements);
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!id)
        return;
      if (!canTakeTreeSnapshot)
        return;
      const { disclosureElement } = store.getState();
      const dialog = ref.current;
      const persistentElements = getPersistentElementsProp() || [];
      const allElements = [
        dialog,
        ...persistentElements,
        ...nestedDialogs.map((dialog2) => dialog2.getState().contentElement)
      ];
      if (!shouldDisableAccessibilityTree) {
        return _QK4GI6B3cjs.markTreeOutside.call(void 0, id, [disclosureElement, ...allElements]);
      }
      if (modal) {
        return _misc.chain.call(void 0, 
          _QK4GI6B3cjs.markTreeOutside.call(void 0, id, allElements),
          _COHI5HTScjs.disableTreeOutside.call(void 0, id, allElements)
        );
      }
      return _misc.chain.call(void 0, 
        _QK4GI6B3cjs.markTreeOutside.call(void 0, id, [disclosureElement, ...allElements]),
        _F4RJLWZGcjs.disableAccessibilityTreeOutside.call(void 0, id, allElements)
      );
    }, [
      id,
      store,
      canTakeTreeSnapshot,
      getPersistentElementsProp,
      nestedDialogs,
      shouldDisableAccessibilityTree,
      modal
    ]);
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const autoFocusOnShowProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, autoFocusOnShow);
    const [autoFocusEnabled, setAutoFocusEnabled] = _react.useState.call(void 0, false);
    _react.useEffect.call(void 0, () => {
      if (!open)
        return;
      if (!mayAutoFocusOnShow)
        return;
      if (!domReady)
        return;
      if (!(contentElement == null ? void 0 : contentElement.isConnected))
        return;
      const element = getElementFromProp(initialFocus, true) || // If no initial focus is specified, we try to focus the first element
      // with the autofocus attribute. If it's an Ariakit component, the
      // Focusable component will consume the autoFocus prop and add the
      // data-autofocus attribute to the element instead.
      contentElement.querySelector(
        "[data-autofocus=true],[autofocus]"
      ) || // We have to fallback to the first focusable element otherwise portaled
      // dialogs with preserveTabOrder set to true will not receive focus
      // properly because the elements aren't tabbable until the dialog
      // receives focus.
      _focus.getFirstTabbableIn.call(void 0, contentElement, true, portal && preserveTabOrder) || // Finally, we fallback to the dialog element itself.
      contentElement;
      const isElementFocusable = _focus.isFocusable.call(void 0, element);
      if (!autoFocusOnShowProp(isElementFocusable ? element : null))
        return;
      setAutoFocusEnabled(true);
      queueMicrotask(() => {
        element.focus();
        if (!isSafariBrowser)
          return;
        element.scrollIntoView({ block: "nearest", inline: "nearest" });
      });
    }, [
      open,
      mayAutoFocusOnShow,
      domReady,
      contentElement,
      initialFocus,
      portal,
      preserveTabOrder,
      autoFocusOnShowProp
    ]);
    const mayAutoFocusOnHide = !!autoFocusOnHide;
    const autoFocusOnHideProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, autoFocusOnHide);
    const [hasOpened, setHasOpened] = _react.useState.call(void 0, false);
    _react.useEffect.call(void 0, () => {
      if (!open)
        return;
      setHasOpened(true);
      return () => setHasOpened(false);
    }, [open]);
    const focusOnHide = _react.useCallback.call(void 0, 
      (dialog, retry = true) => {
        const { disclosureElement } = store.getState();
        if (isAlreadyFocusingAnotherElement(dialog))
          return;
        let element = getElementFromProp(finalFocus) || disclosureElement;
        if (element == null ? void 0 : element.id) {
          const doc = _dom.getDocument.call(void 0, element);
          const selector = `[aria-activedescendant="${element.id}"]`;
          const composite = doc.querySelector(selector);
          if (composite) {
            element = composite;
          }
        }
        if (element && !_focus.isFocusable.call(void 0, element)) {
          const maybeParentDialog = _dom.closest.call(void 0, element, "[data-dialog]");
          if (maybeParentDialog && maybeParentDialog.id) {
            const doc = _dom.getDocument.call(void 0, maybeParentDialog);
            const selector = `[aria-controls~="${maybeParentDialog.id}"]`;
            const control = doc.querySelector(selector);
            if (control) {
              element = control;
            }
          }
        }
        const isElementFocusable = element && _focus.isFocusable.call(void 0, element);
        if (!isElementFocusable && retry) {
          requestAnimationFrame(() => focusOnHide(dialog, false));
          return;
        }
        if (!autoFocusOnHideProp(isElementFocusable ? element : null))
          return;
        if (!isElementFocusable)
          return;
        element == null ? void 0 : element.focus();
      },
      [store, finalFocus, autoFocusOnHideProp]
    );
    _5WLTMVVQcjs.useSafeLayoutEffect.call(void 0, () => {
      if (open)
        return;
      if (!hasOpened)
        return;
      if (!mayAutoFocusOnHide)
        return;
      const dialog = ref.current;
      focusOnHide(dialog);
    }, [open, hasOpened, domReady, mayAutoFocusOnHide, focusOnHide]);
    _react.useEffect.call(void 0, () => {
      if (!hasOpened)
        return;
      if (!mayAutoFocusOnHide)
        return;
      const dialog = ref.current;
      return () => focusOnHide(dialog);
    }, [hasOpened, mayAutoFocusOnHide, focusOnHide]);
    const hideOnEscapeProp = _5WLTMVVQcjs.useBooleanEvent.call(void 0, hideOnEscape);
    _react.useEffect.call(void 0, () => {
      if (!domReady)
        return;
      if (!mounted)
        return;
      const onKeyDown = (event) => {
        if (event.key !== "Escape")
          return;
        if (event.defaultPrevented)
          return;
        const dialog = ref.current;
        if (!dialog)
          return;
        if (_QK4GI6B3cjs.isElementMarked.call(void 0, dialog))
          return;
        const target = event.target;
        if (!target)
          return;
        const { disclosureElement } = store.getState();
        const isValidTarget = () => {
          if (target.tagName === "BODY")
            return true;
          if (_dom.contains.call(void 0, dialog, target))
            return true;
          if (!disclosureElement)
            return true;
          if (_dom.contains.call(void 0, disclosureElement, target))
            return true;
          return false;
        };
        if (!isValidTarget())
          return;
        if (!hideOnEscapeProp(event))
          return;
        store.hide();
      };
      return _events.addGlobalEventListener.call(void 0, "keydown", onKeyDown, true);
    }, [store, domReady, mounted, hideOnEscapeProp]);
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _SOPRUU56cjs.HeadingLevel, { level: modal ? 1 : void 0, children: element }),
      [modal]
    );
    const hiddenProp = props.hidden;
    const alwaysVisible = props.alwaysVisible;
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => {
        if (!backdrop)
          return element;
        return /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _R7CSCUVWcjs.DialogBackdrop,
            {
              store,
              backdrop,
              backdropProps,
              hidden: hiddenProp,
              alwaysVisible
            }
          ),
          element
        ] });
      },
      [store, backdrop, backdropProps, hiddenProp, alwaysVisible]
    );
    const [headingId, setHeadingId] = _react.useState.call(void 0, );
    const [descriptionId, setDescriptionId] = _react.useState.call(void 0, );
    props = _5WLTMVVQcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _W6ZRSMO5cjs.DialogScopedContextProvider, { value: store, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _W6ZRSMO5cjs.DialogHeadingContext.Provider, { value: setHeadingId, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _W6ZRSMO5cjs.DialogDescriptionContext.Provider, { value: setDescriptionId, children: element }) }) }),
      [store]
    );
    props = _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {
      id,
      "data-dialog": "",
      role: "dialog",
      tabIndex: focusable ? -1 : void 0,
      "aria-labelledby": headingId,
      "aria-describedby": descriptionId
    }, props), {
      ref: _5WLTMVVQcjs.useMergeRefs.call(void 0, ref, props.ref)
    });
    props = _A6H7IIHJcjs.useFocusableContainer.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props), {
      autoFocusOnShow: autoFocusEnabled
    }));
    props = _L2VQ4YLNcjs.useDisclosureContent.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, { store }, props));
    props = _GQAB4M3Bcjs.useFocusable.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props), { focusable }));
    props = _MNZPRWGCcjs.usePortal.call(void 0, _72I2GWXFcjs.__spreadProps.call(void 0, _72I2GWXFcjs.__spreadValues.call(void 0, { portal }, props), { portalRef, preserveTabOrder }));
    return props;
  }
);
function createDialogComponent(Component, useProviderContext = _W6ZRSMO5cjs.useDialogProviderContext) {
  return _Z5PUIG6Acjs.createComponent.call(void 0, (props) => {
    const context = useProviderContext();
    const store = props.store || context;
    const mounted = _EVNF7KMTcjs.useStoreState.call(void 0, 
      store,
      (state) => !props.unmountOnHide || (state == null ? void 0 : state.mounted) || !!props.open
    );
    if (!mounted)
      return null;
    return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, Component, _72I2GWXFcjs.__spreadValues.call(void 0, {}, props));
  });
}
var Dialog = createDialogComponent(
  _Z5PUIG6Acjs.createComponent.call(void 0, (props) => {
    const htmlProps = useDialog(props);
    return _Z5PUIG6Acjs.createElement.call(void 0, "div", htmlProps);
  }),
  _W6ZRSMO5cjs.useDialogProviderContext
);
if (process.env.NODE_ENV !== "production") {
  Dialog.displayName = "Dialog";
}





exports.useDialog = useDialog; exports.createDialogComponent = createDialogComponent; exports.Dialog = Dialog;
