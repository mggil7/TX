import type { KeyboardEvent as ReactKeyboardEvent } from "react";
import type { BooleanOrCallback } from "@ariakit/core/utils/types";
import type { FocusableOptions } from "../focusable/focusable.js";
import type { As, Props } from "../utils/types.js";
import type { CompositeStore } from "./composite-store.js";
/**
 * Returns props to create a `Composite` component.
 * @see https://ariakit.org/components/composite
 * @example
 * ```jsx
 * const store = useCompositeStore();
 * const props = useComposite({ store });
 * <Role {...props}>
 *   <CompositeItem>Item 1</CompositeItem>
 *   <CompositeItem>Item 2</CompositeItem>
 * </Role>
 * ```
 */
export declare const useComposite: import("../utils/types.js").Hook<CompositeOptions<"div">>;
/**
 * Renders a composite widget.
 * @see https://ariakit.org/components/composite
 * @example
 * ```jsx
 * const composite = useCompositeStore();
 * <Composite store={composite}>
 *   <CompositeItem>Item 1</CompositeItem>
 *   <CompositeItem>Item 2</CompositeItem>
 * </Composite>
 * ```
 */
export declare const Composite: import("../utils/types.js").Component<CompositeOptions<"div">>;
export interface CompositeOptions<T extends As = "div"> extends FocusableOptions<T> {
    /**
     * Object returned by the `useCompositeStore` hook.
     */
    store?: CompositeStore;
    /**
     * Whether the component should behave as a composite widget. This prop should
     * be set to `false` when combining different composite widgets where only one
     * should behave as such.
     * @default true
     */
    composite?: boolean;
    /**
     * Whether the active composite item should receive focus when `store.move` is
     * called.
     * @default true
     */
    focusOnMove?: boolean;
    /**
     * Whether the composite widget should move focus to an item when pressing
     * arrow keys.
     * @default true
     */
    moveOnKeyPress?: BooleanOrCallback<ReactKeyboardEvent<HTMLElement>>;
}
export type CompositeProps<T extends As = "div"> = Props<CompositeOptions<T>>;
