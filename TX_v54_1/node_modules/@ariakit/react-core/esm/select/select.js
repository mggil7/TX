import {
  usePopoverDisclosure
} from "../__chunks/HXYXHHNW.js";
import "../__chunks/5EAW3TWZ.js";
import "../__chunks/LRDCOOWL.js";
import "../__chunks/4FNI7F6H.js";
import "../__chunks/TONP6TZ5.js";
import {
  SelectArrow
} from "../__chunks/WJZPOH5E.js";
import "../__chunks/5HSRXC5S.js";
import {
  useCompositeTypeahead
} from "../__chunks/YVYWIVKG.js";
import {
  SelectScopedContextProvider,
  useSelectProviderContext
} from "../__chunks/US4OMDIO.js";
import "../__chunks/CAIAWNDV.js";
import "../__chunks/OXPV2NBK.js";
import "../__chunks/5C7J4IAS.js";
import "../__chunks/74KKBFVP.js";
import "../__chunks/547DFODS.js";
import "../__chunks/5YYGDU4E.js";
import "../__chunks/56KWVYDN.js";
import "../__chunks/YTHH33BK.js";
import "../__chunks/BMLNRUFQ.js";
import {
  createComponent,
  createElement,
  createHook
} from "../__chunks/CFEUKV6C.js";
import {
  useBooleanEvent,
  useEvent,
  useMergeRefs,
  useWrapElement
} from "../__chunks/J7Q2EO23.js";
import "../__chunks/CP3U4HPL.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "../__chunks/PNRLI7OV.js";

// src/select/select.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import { getPopupRole } from "@ariakit/core/utils/dom";
import { queueBeforeEvent } from "@ariakit/core/utils/events";
import { invariant } from "@ariakit/core/utils/misc";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
function getSelectedValues(select) {
  return Array.from(select.selectedOptions).map((option) => option.value);
}
function nextWithValue(store, next) {
  return () => {
    const nextId = next();
    if (!nextId)
      return;
    let i = 0;
    let nextItem = store.item(nextId);
    const firstItem = nextItem;
    while (nextItem && nextItem.value == null) {
      const nextId2 = next(++i);
      if (!nextId2)
        return;
      nextItem = store.item(nextId2);
      if (nextItem === firstItem)
        break;
    }
    return nextItem == null ? void 0 : nextItem.id;
  };
}
var useSelect = createHook(
  (_a) => {
    var _b = _a, {
      store,
      name,
      form,
      required,
      showOnKeyDown = true,
      moveOnKeyDown = true,
      toggleOnClick = false,
      toggleOnPress = !toggleOnClick
    } = _b, props = __objRest(_b, [
      "store",
      "name",
      "form",
      "required",
      "showOnKeyDown",
      "moveOnKeyDown",
      "toggleOnClick",
      "toggleOnPress"
    ]);
    const context = useSelectProviderContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "Select must receive a `store` prop or be wrapped in a SelectProvider component."
    );
    toggleOnPress = toggleOnClick ? false : toggleOnPress;
    const onKeyDownProp = props.onKeyDown;
    const showOnKeyDownProp = useBooleanEvent(showOnKeyDown);
    const moveOnKeyDownProp = useBooleanEvent(moveOnKeyDown);
    const toggleOnPressProp = useBooleanEvent(toggleOnPress);
    const placement = store.useState("placement");
    const dir = placement.split("-")[0];
    const value = store.useState("value");
    const multiSelectable = Array.isArray(value);
    const onKeyDown = useEvent((event) => {
      var _a2;
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      if (!store)
        return;
      const { orientation, items: items2, activeId } = store.getState();
      if (event.key === " " || event.key === "Enter") {
        if (toggleOnPressProp(event)) {
          event.preventDefault();
          store.toggle();
        }
      }
      const isVertical = orientation !== "horizontal";
      const isHorizontal = orientation !== "vertical";
      const isGrid = !!((_a2 = items2.find(
        (item) => !item.disabled && item.value != null
      )) == null ? void 0 : _a2.rowId);
      const moveKeyMap = {
        ArrowUp: (isGrid || isVertical) && nextWithValue(store, store.up),
        ArrowRight: (isGrid || isHorizontal) && nextWithValue(store, store.next),
        ArrowDown: (isGrid || isVertical) && nextWithValue(store, store.down),
        ArrowLeft: (isGrid || isHorizontal) && nextWithValue(store, store.previous)
      };
      const getId = moveKeyMap[event.key];
      if (getId && moveOnKeyDownProp(event)) {
        event.preventDefault();
        store.move(getId());
      }
      const isTopOrBottom = dir === "top" || dir === "bottom";
      const isLeft = dir === "left";
      const isRight = dir === "right";
      const canShowKeyMap = {
        ArrowDown: isTopOrBottom,
        ArrowUp: isTopOrBottom,
        ArrowLeft: isLeft,
        ArrowRight: isRight
      };
      const canShow = canShowKeyMap[event.key];
      if (canShow && showOnKeyDownProp(event)) {
        event.preventDefault();
        store.show();
        store.move(activeId);
      }
    });
    const onMouseDownProp = props.onMouseDown;
    const onMouseDown = useEvent((event) => {
      onMouseDownProp == null ? void 0 : onMouseDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.button)
        return;
      if (event.ctrlKey)
        return;
      if (!toggleOnPressProp(event))
        return;
      const element = event.currentTarget;
      queueBeforeEvent(element, "focusin", () => {
        store == null ? void 0 : store.setDisclosureElement(element);
        store == null ? void 0 : store.toggle();
      });
    });
    props = useWrapElement(
      props,
      (element) => /* @__PURE__ */ jsx(SelectScopedContextProvider, { value: store, children: element }),
      [store]
    );
    const [autofill, setAutofill] = useState(false);
    const nativeSelectChangedRef = useRef(false);
    useEffect(() => {
      const nativeSelectChanged = nativeSelectChangedRef.current;
      nativeSelectChangedRef.current = false;
      if (nativeSelectChanged)
        return;
      setAutofill(false);
    }, [value]);
    const labelId = store.useState((state) => {
      var _a2;
      return (_a2 = state.labelElement) == null ? void 0 : _a2.id;
    });
    const label = props["aria-label"];
    const labelledBy = props["aria-labelledby"] || labelId;
    const items = store.useState("items");
    const values = useMemo(
      // Filter out items without value and duplicate values.
      () => [...new Set(items.map((i) => i.value).filter((v) => v != null))],
      [items]
    );
    props = useWrapElement(
      props,
      (element) => {
        if (!name)
          return element;
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(
            "select",
            {
              style: {
                border: 0,
                clip: "rect(0 0 0 0)",
                height: "1px",
                margin: "-1px",
                overflow: "hidden",
                padding: 0,
                position: "absolute",
                whiteSpace: "nowrap",
                width: "1px"
              },
              tabIndex: -1,
              "aria-hidden": true,
              "aria-label": label,
              "aria-labelledby": labelledBy,
              name,
              form,
              required,
              value,
              multiple: multiSelectable,
              onFocus: () => {
                var _a2;
                return (_a2 = store == null ? void 0 : store.getState().selectElement) == null ? void 0 : _a2.focus();
              },
              onChange: (event) => {
                nativeSelectChangedRef.current = true;
                setAutofill(true);
                store == null ? void 0 : store.setValue(
                  multiSelectable ? getSelectedValues(event.target) : event.target.value
                );
              },
              children: values.map((value2) => /* @__PURE__ */ jsx("option", { value: value2, children: value2 }, value2))
            }
          ),
          element
        ] });
      },
      [
        store,
        label,
        labelledBy,
        name,
        form,
        required,
        value,
        multiSelectable,
        values
      ]
    );
    const children = /* @__PURE__ */ jsxs(Fragment, { children: [
      value,
      /* @__PURE__ */ jsx(SelectArrow, {})
    ] });
    const contentElement = store.useState("contentElement");
    props = __spreadProps(__spreadValues({
      role: "combobox",
      "aria-autocomplete": "none",
      "aria-labelledby": labelId,
      "aria-haspopup": getPopupRole(contentElement, "listbox"),
      "data-autofill": autofill ? "" : void 0,
      "data-name": name,
      children
    }, props), {
      ref: useMergeRefs(store.setSelectElement, props.ref),
      onKeyDown,
      onMouseDown
    });
    props = usePopoverDisclosure(__spreadValues({ store, toggleOnClick }, props));
    props = useCompositeTypeahead(__spreadValues({ store }, props));
    return props;
  }
);
var Select = createComponent((props) => {
  const htmlProps = useSelect(props);
  return createElement("button", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Select.displayName = "Select";
}
export {
  Select,
  useSelect
};
